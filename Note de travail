Structure principale de la fonction:

ft_printf --> pf_manager
(si pas de %) -> pf_str_manager(va ecrire chaque caractere de la chaine)

(si un %) --> ft_parsing(a renommer): Initialise flag
	-> fill_parsing: va prendre la section entre le % et les conversions)
et l'isole dans une chaine(flag.parsing)
	-> fill_flag: A partir de flag.parsing, il va trier toute les informations
dans une structure.

	--> ft_conversion (fonction a separer): une fonction est dÃ©diÃ©e
a chaque conversion, qui contient tout les options qui lui sont propres.
	-> Pour chaque conversion, une fonction revient, il s'agit de handle_field:
Son role est de mettre en place les regles de la taille minimum de champs en fonction
des options. Ces regles sont communes Ã  chaqu'un des flags.


NB 
	- Toute les fonctions que vous allez trouvÃ© dans (conversion/parsing)_utils sont des
fonctions simples assujetties aux fonctions principales de parsing/conversion.

	- Pour certain tests, il faut enlever __attribute__ (quand on teste dans son coin)

	- Les tests faux de basic tests portent sur des fonctionnalitÃ©es que nous n'avons pas encore
codÃ©es.

	- Certain tests de moulitest sortent de l'espace...

	- J'ai fait un microscript (launch_test) pour lancer des tests :) c'est de la demer mais ca fait gagner du
temps ;). Par contre , pour le moment pour l'utiliser j'ai du crÃ©er un autre main de test (main1.c)
que j'ai pas mis dans le git pour que Ã§a reste propre. 

	- Je suis vraiment pourri en Makefile, mais il n'est pas "linkÃ©" (tout se recompile a chaque fois)
et le main de test fait parti des objets a compilÃ© pour la lib. (DÃ¨s que je touche a truc dedans tout
explose du coup j'evite... :$)

	- Oui, dans l'etat ft_printf est plus une clio qu'une ferrari, mais je pense que notamment fill_flag
peut etre grave ameliorer comme on avait parlÃ© avec Cam!

Si on se revoit pas avant que je parte, plien de bonne chose et on se voit a NOISY LE CHAMPS ğŸ’¥ğŸ’¥
